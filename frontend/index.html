<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptex - Secure Upload</title>
    <link rel="stylesheet" href="/frontend/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
</head>

<body>
    <main class="canvas-container">
        <div class="bento-container">
            <!-- Back Arrow -->
            <button class="back-arrow" id="backArrow" aria-label="Go back">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M19 12H5M5 12L12 19M5 12L12 5" stroke="white" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" />
                </svg>
            </button>

            <h1 class="cryptex-title">Cryptex</h1>
            <div class="glass-rectangle" id="mainBlock">
                <div class="filename-overlay" id="filenameOverlay">
                    <div class="filename-text" id="filenameText"></div>
                </div>
            </div>

            <input type="file" id="fileInput" class="file-input-hidden" accept=".bin,.elf,.o,.so,.exe,.img,.fw,.hex">

            <div class="bento-box-top card">
                <div class="badge"></div>
                <div class="title">File type</div>
                <div class="type-row">
                    <div class="ext"
                        style="color: #E85002 !important; background: transparent; z-index: 999; position: relative; display: inline-block;">
                        .bin</div>
                    <img src="/frontend/FILE.svg" alt="Icon" class="icon">
                </div>
            </div>
            <div class="bento-box-bottom" id="uploadBlock">
                <div class="badge-bottom"></div>
                <img src="/frontend/cloud.svg" alt="Cloud" class="cloud-icon">
                <div class="upload-text">Upload</div>
            </div>
        </div>

        <!-- Upload Modal -->
        <div class="upload-modal-overlay" id="uploadModal">
            <div class="upload-modal">
                <div class="modal-header">
                    <h2>Uploading</h2>
                    <button class="modal-close" id="modalClose">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                            <path d="M18 6L6 18M6 6l12 12" stroke="white" stroke-width="2" stroke-linecap="round" />
                        </svg>
                    </button>
                </div>

                <div class="file-info">
                    <div class="file-icon-modal">
                        <img src="/frontend/FILE.svg" alt="File" class="file-svg-icon">
                    </div>
                    <div class="file-details">
                        <div class="file-name-modal" id="modalFileName">document.bin</div>
                        <div class="file-size" id="modalFileSize">2.4 MB</div>
                    </div>
                </div>

                <div class="progress-container">
                    <div class="progress-label">
                        <span id="progressPercent">0%</span>
                        <span id="progressSpeed">0 KB/s</span>
                    </div>
                    <div class="liquid-progress">
                        <div class="liquid-fill" id="liquidFill"></div>
                        <div class="liquid-wave"></div>
                    </div>
                </div>

                <div class="upload-status" id="uploadStatus">
                    <img src="/frontend/progresstabicons/extract.png" alt="Status" class="status-icon" id="statusIcon">
                    <div class="status-content">
                        <span class="status-text" id="statusText">Extracting data...</span>
                        <div class="loading-wave">
                            <div class="loading-bar"></div>
                            <div class="loading-bar"></div>
                            <div class="loading-bar"></div>
                            <div class="loading-bar"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        const mainBlock = document.getElementById('mainBlock');
        const uploadBlock = document.getElementById('uploadBlock');
        const fileInput = document.getElementById('fileInput');
        const filenameOverlay = document.getElementById('filenameOverlay');
        const filenameText = document.getElementById('filenameText');
        const backArrow = document.getElementById('backArrow');
        const uploadModal = document.getElementById('uploadModal');
        const modalClose = document.getElementById('modalClose');
        const modalFileName = document.getElementById('modalFileName');
        const modalFileSize = document.getElementById('modalFileSize');
        const liquidFill = document.getElementById('liquidFill');
        const progressPercent = document.getElementById('progressPercent');
        const progressSpeed = document.getElementById('progressSpeed');
        const uploadStatus = document.getElementById('uploadStatus');

        let hasFile = false;
        let currentFile = null;

        // Click handlers for upload
        mainBlock.addEventListener('click', () => fileInput.click());

        // Upload button triggers file selection then modal
        uploadBlock.addEventListener('click', () => {
            if (hasFile && currentFile) {
                showUploadModal();
            } else {
                fileInput.click();
            }
        });

        // File selection handler
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file extension
                const fileName = file.name.toLowerCase();
                if (!fileName.endsWith('.bin')) {
                    alert('Please upload a .bin file only!');
                    fileInput.value = '';
                    return;
                }

                hasFile = true;
                currentFile = file;
                filenameText.textContent = file.name;

                // GSAP animation sequence
                const tl = gsap.timeline();

                tl.to(filenameOverlay, {
                    opacity: 1,
                    duration: 0.4,
                    ease: "power2.out"
                })
                    .from(filenameText, {
                        y: 30,
                        opacity: 0,
                        duration: 0.6,
                        ease: "power3.out"
                    }, "-=0.2")
                    .to(backArrow, {
                        opacity: 1,
                        x: 0,
                        duration: 0.4,
                        ease: "power2.out"
                    }, "-=0.4");
            }
        });

        // Show upload modal with animations
        function showUploadModal() {
            if (!currentFile) return;

            // Update modal info with real file data
            modalFileName.textContent = currentFile.name;
            modalFileSize.textContent = formatFileSize(currentFile.size);

            // Show modal with GSAP
            gsap.to(uploadModal, {
                display: 'flex',
                opacity: 1,
                duration: 0.3,
                ease: "power2.out",
                onStart: () => {
                    uploadModal.style.display = 'flex';
                }
            });

            gsap.from('.upload-modal', {
                y: 50,
                scale: 0.95,
                opacity: 0,
                duration: 0.5,
                ease: "back.out(1.2)"
            });

            // Start upload simulation
            simulateUpload();
        }

        // Hide modal
        function hideModal() {
            gsap.to(uploadModal, {
                opacity: 0,
                duration: 0.3,
                ease: "power2.in",
                onComplete: () => {
                    uploadModal.style.display = 'none';
                    resetUpload();
                }
            });
        }

        modalClose.addEventListener('click', hideModal);
        uploadModal.addEventListener('click', (e) => {
            if (e.target === uploadModal) hideModal();
        });

        // Real upload with API integration
        async function simulateUpload() {
            if (!currentFile) return;

            const formData = new FormData();
            formData.append('file', currentFile);

            let progress = 0;
            const statusTextEl = document.getElementById('statusText');
            const statusIconEl = document.getElementById('statusIcon');

            const statuses = [
                { percent: 0, text: 'Uploading file...', icon: '/frontend/progresstabicons/extract.png' },
                { percent: 20, text: 'Extracting firmware...', icon: '/frontend/progresstabicons/data-transformation.png' },
                { percent: 40, text: 'Analyzing binary...', icon: '/frontend/progresstabicons/filter.png' },
                { percent: 60, text: 'Detecting crypto...', icon: '/frontend/progresstabicons/data-classification.png' },
                { percent: 80, text: 'Verifying results...', icon: '/frontend/progresstabicons/verifying.png' },
                { percent: 95, text: 'Finalizing...', icon: '/frontend/progresstabicons/aggregate.png' }
            ];

            function updateProgress(percent, statusIndex) {
                gsap.to(liquidFill, { width: `${percent}%`, duration: 0.3, ease: "power1.out" });
                progressPercent.textContent = `${percent}%`;

                const status = statuses[statusIndex];
                if (status && statusTextEl.textContent !== status.text) {
                    statusTextEl.textContent = status.text;
                    statusIconEl.src = status.icon;
                    progressSpeed.textContent = 'Processing...';
                }
            }

            // Show initial progress
            updateProgress(5, 0);

            try {
                // Create XMLHttpRequest for upload progress tracking
                const xhr = new XMLHttpRequest();

                const uploadPromise = new Promise((resolve, reject) => {
                    xhr.upload.addEventListener('progress', (e) => {
                        if (e.lengthComputable) {
                            const uploadPercent = Math.round((e.loaded / e.total) * 20);
                            updateProgress(uploadPercent, 0);
                        }
                    });

                    xhr.addEventListener('load', () => {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            resolve(JSON.parse(xhr.responseText));
                        } else {
                            reject(new Error(`Upload failed: ${xhr.status}`));
                        }
                    });

                    xhr.addEventListener('error', () => reject(new Error('Network error')));
                    xhr.open('POST', '/api/analyze');
                    xhr.send(formData);
                });

                // Simulate analysis progress while waiting
                let analysisInterval = setInterval(() => {
                    progress = Math.min(progress + 5, 90);
                    const statusIdx = Math.floor(progress / 20);
                    updateProgress(progress, Math.min(statusIdx, statuses.length - 1));
                }, 500);

                // Wait for API response
                const result = await uploadPromise;
                clearInterval(analysisInterval);

                // Complete
                updateProgress(100, statuses.length - 1);
                statusTextEl.textContent = '✓ Analysis complete!';
                statusIconEl.style.opacity = '0';
                uploadStatus.style.color = '#4ade80';
                gsap.to('.loading-wave', { opacity: 0, duration: 0.3 });

                // Store results for results page
                sessionStorage.setItem('cryptoHunterJobId', result.job_id);
                sessionStorage.setItem('cryptoHunterResults', JSON.stringify(result));

                // Redirect to results
                setTimeout(() => {
                    window.location.href = '/cryptex/results';
                }, 1000);

            } catch (error) {
                console.error('Upload error:', error);
                statusTextEl.textContent = '✗ ' + error.message;
                uploadStatus.style.color = '#ef4444';
                gsap.to('.loading-wave', { opacity: 0, duration: 0.3 });
            }
        }


        // Reset upload state
        function resetUpload() {
            const statusIconEl = document.getElementById('statusIcon');
            gsap.set(liquidFill, { width: '0%' });
            gsap.set('.loading-wave', { opacity: 1 });
            progressPercent.textContent = '0%';
            progressSpeed.textContent = '0 KB/s';
            document.getElementById('statusText').textContent = 'Extracting data...';
            statusIconEl.src = '/frontend/progresstabicons/extract.png';
            statusIconEl.style.opacity = '1';
            uploadStatus.style.color = '#FFFFFF';
        }

        // Back arrow click - reset
        backArrow.addEventListener('click', resetFile);

        function resetFile() {
            if (!hasFile) return;

            const tl = gsap.timeline();

            tl.to(backArrow, {
                opacity: 0,
                x: -20,
                duration: 0.3,
                ease: "power2.in"
            })
                .to(filenameOverlay, {
                    opacity: 0,
                    duration: 0.3,
                    ease: "power2.in",
                    onComplete: () => {
                        fileInput.value = '';
                        filenameText.textContent = '';
                        hasFile = false;
                        currentFile = null;
                    }
                }, "-=0.2");
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (uploadModal.style.display === 'flex') {
                    hideModal();
                } else if (hasFile) {
                    resetFile();
                }
            }

            if ((e.key === ' ' || e.key === 'Enter') && !hasFile && uploadModal.style.display !== 'flex') {
                e.preventDefault();
                fileInput.click();
            }

            if ((e.key === 'Delete' || e.key === 'Backspace') && hasFile && uploadModal.style.display !== 'flex') {
                resetFile();
            }
        });

        // Hover animations
        backArrow.addEventListener('mouseenter', () => {
            gsap.to(backArrow, { x: -5, duration: 0.3, ease: "power2.out" });
        });

        backArrow.addEventListener('mouseleave', () => {
            if (hasFile) gsap.to(backArrow, { x: 0, duration: 0.3, ease: "power2.out" });
        });

        // Utility function
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }
    </script>
</body>

</html>