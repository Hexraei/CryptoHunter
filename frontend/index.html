<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptex - Secure Upload</title>
    <link rel="stylesheet" href="/frontend/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
</head>

<body>
    <main class="canvas-container">
        <div class="bento-container">
            <!-- Back Arrow -->
            <button class="back-arrow" id="backArrow" aria-label="Go back">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M19 12H5M5 12L12 19M5 12L12 5" stroke="white" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" />
                </svg>
            </button>

            <h1 class="cryptex-title">Cryptex</h1>
            <div class="glass-rectangle" id="mainBlock">
                <div class="filename-overlay" id="filenameOverlay">
                    <div class="filename-text" id="filenameText"></div>
                </div>
            </div>

            <input type="file" id="fileInput" class="file-input-hidden"
                accept=".bin,.elf,.o,.so,.exe,.img,.fw,.hex,.rom,.blob,.raw,.ddc,.sfi,.ko,.a,.trx,.chk,.dlf,.rmt,.uimage,.zip,.gz,.tar,.tgz,.bz2,.xz,.lzma,.7z,.rar,.squashfs,.jffs2,.ubifs,.cramfs,.yaffs,.yaffs2,.ext2,.ext3,.ext4,.srec,.s19,.mot,.ihex,.apk,.dex,.odex,*">

            <div class="bento-box-top card">
                <div class="badge"></div>
                <div class="title">File type</div>
                <div class="type-row">
                    <div class="ext"
                        style="color: #E85002 !important; background: transparent; z-index: 999; position: relative; display: inline-block;">
                        Firmware</div>
                    <img src="/frontend/FILE.svg" alt="Icon" class="icon">
                </div>
            </div>
            <div class="bento-box-bottom" id="uploadBlock">
                <div class="badge-bottom"></div>
                <img src="/frontend/cloud.svg" alt="Cloud" class="cloud-icon">
                <div class="upload-text">Upload</div>
            </div>

            <!-- System Status -->
            <div id="systemStatus" style="margin-top: 24px; font-size: 11px; color: #64748b; display: none;">
                <div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
                </div>
            </div>
        </div>

        <!-- Upload Modal -->
        <div class="upload-modal-overlay" id="uploadModal">
            <div class="upload-modal" style="max-width: 500px;">
                <div class="modal-header">
                    <h2>Processing</h2>
                    <button class="modal-close" id="modalClose">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                            <path d="M18 6L6 18M6 6l12 12" stroke="white" stroke-width="2" stroke-linecap="round" />
                        </svg>
                    </button>
                </div>

                <div class="file-info">
                    <div class="file-icon-modal">
                        <img src="/frontend/FILE.svg" alt="File" class="file-svg-icon">
                    </div>
                    <div class="file-details">
                        <div class="file-name-modal" id="modalFileName">document.bin</div>
                        <div class="file-size" id="modalFileSize">2.4 MB</div>
                    </div>
                </div>

                <div class="progress-container">
                    <div class="progress-label">
                        <span id="progressPercent">0%</span>
                        <span id="progressSpeed">0 KB/s</span>
                    </div>
                    <div class="liquid-progress">
                        <div class="liquid-fill" id="liquidFill"></div>
                        <div class="liquid-wave"></div>
                    </div>
                </div>

                <div class="upload-status" id="uploadStatus">
                    <img src="/frontend/progresstabicons/extract.png" alt="Status" class="status-icon" id="statusIcon">
                    <div class="status-content">
                        <span class="status-text" id="statusText">Initializing...</span>
                        <div class="loading-wave">
                            <div class="loading-bar"></div>
                            <div class="loading-bar"></div>
                            <div class="loading-bar"></div>
                            <div class="loading-bar"></div>
                        </div>
                    </div>
                </div>

                <!-- Processing Log -->
                <div class="processing-log" id="processingLog"
                    style="margin-top: 16px; max-height: 200px; overflow-y: auto; font-family: 'SF Mono', Consolas, monospace; font-size: 11px; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 12px; display: none;">
                    <div style="color: #64748b; margin-bottom: 8px; font-weight: 600;">Pipeline Log</div>
                    <div id="logContent"></div>
                </div>
            </div>
        </div>
    </main>

    <script>
        const mainBlock = document.getElementById('mainBlock');
        const uploadBlock = document.getElementById('uploadBlock');
        const fileInput = document.getElementById('fileInput');
        const filenameOverlay = document.getElementById('filenameOverlay');
        const filenameText = document.getElementById('filenameText');
        const backArrow = document.getElementById('backArrow');
        const uploadModal = document.getElementById('uploadModal');
        const modalClose = document.getElementById('modalClose');
        const modalFileName = document.getElementById('modalFileName');
        const modalFileSize = document.getElementById('modalFileSize');
        const liquidFill = document.getElementById('liquidFill');
        const progressPercent = document.getElementById('progressPercent');
        const progressSpeed = document.getElementById('progressSpeed');
        const uploadStatus = document.getElementById('uploadStatus');

        let hasFile = false;
        let currentFile = null;

        // Click handlers for upload
        mainBlock.addEventListener('click', () => fileInput.click());

        // Upload button triggers file selection then modal
        uploadBlock.addEventListener('click', () => {
            if (hasFile && currentFile) {
                showUploadModal();
            } else {
                fileInput.click();
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file extension - accept all binwalk-supported formats
                const fileName = file.name.toLowerCase();
                const supportedExtensions = [
                    // Raw firmware/binary
                    '.bin', '.img', '.fw', '.rom', '.blob', '.raw', '.ddc', '.sfi',
                    // ELF executables
                    '.elf', '.so', '.o', '.a', '.ko',
                    // Router/IoT specific
                    '.trx', '.chk', '.dlf', '.rmt', '.uimage',
                    // Compressed archives (binwalk can extract)
                    '.zip', '.gz', '.tar', '.tgz', '.bz2', '.xz', '.lzma', '.7z', '.rar',
                    // Filesystem images
                    '.squashfs', '.jffs2', '.ubifs', '.cramfs', '.yaffs', '.yaffs2', '.ext2', '.ext3', '.ext4',
                    // Other firmware formats
                    '.hex', '.srec', '.s19', '.mot', '.ihex',
                    // Android
                    '.apk', '.dex', '.odex',
                    // Allow any file if no extension (common for firmware)
                ];

                const hasExtension = fileName.includes('.');
                const isSupported = !hasExtension || supportedExtensions.some(ext => fileName.endsWith(ext));

                if (!isSupported) {
                    alert('Unsupported file format. Supported: firmware (.bin, .img, .fw, .elf), archives (.zip, .gz, .tar), filesystem images (.squashfs, .jffs2)');
                    fileInput.value = '';
                    return;
                }

                hasFile = true;
                currentFile = file;
                filenameText.textContent = file.name;

                // GSAP animation sequence
                const tl = gsap.timeline();

                tl.to(filenameOverlay, {
                    opacity: 1,
                    duration: 0.4,
                    ease: "power2.out"
                })
                    .from(filenameText, {
                        y: 30,
                        opacity: 0,
                        duration: 0.6,
                        ease: "power3.out"
                    }, "-=0.2")
                    .to(backArrow, {
                        opacity: 1,
                        x: 0,
                        duration: 0.4,
                        ease: "power2.out"
                    }, "-=0.4");
            }
        });

        // Show upload modal with animations
        function showUploadModal() {
            if (!currentFile) return;

            // Update modal info with real file data
            modalFileName.textContent = currentFile.name;
            modalFileSize.textContent = formatFileSize(currentFile.size);

            // Show modal with GSAP
            gsap.to(uploadModal, {
                display: 'flex',
                opacity: 1,
                duration: 0.3,
                ease: "power2.out",
                onStart: () => {
                    uploadModal.style.display = 'flex';
                }
            });

            gsap.from('.upload-modal', {
                y: 50,
                scale: 0.95,
                opacity: 0,
                duration: 0.5,
                ease: "back.out(1.2)"
            });

            // Start upload simulation
            simulateUpload();
        }

        // Hide modal
        function hideModal() {
            gsap.to(uploadModal, {
                opacity: 0,
                duration: 0.3,
                ease: "power2.in",
                onComplete: () => {
                    uploadModal.style.display = 'none';
                    resetUpload();
                }
            });
        }

        modalClose.addEventListener('click', hideModal);
        uploadModal.addEventListener('click', (e) => {
            if (e.target === uploadModal) hideModal();
        });

        // Real upload with API integration
        async function simulateUpload() {
            if (!currentFile) return;

            const formData = new FormData();
            formData.append('file', currentFile);

            let progress = 0;
            const statusTextEl = document.getElementById('statusText');
            const statusIconEl = document.getElementById('statusIcon');
            const processingLog = document.getElementById('processingLog');
            const logContent = document.getElementById('logContent');

            // Initialize log
            processingLog.style.display = 'block';
            logContent.innerHTML = '';
            const startTime = performance.now();
            const logEntries = [];

            function addLogEntry(message, type = 'info') {
                const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
                const colors = { info: '#94a3b8', success: '#22c55e', warning: '#f59e0b', step: '#60a5fa' };
                const entry = `<div style="color:${colors[type] || colors.info};margin-bottom:4px;"><span style="color:#64748b;">[${elapsed}s]</span> ${message}</div>`;
                logContent.innerHTML += entry;
                logContent.scrollTop = logContent.scrollHeight;
                logEntries.push({ time: elapsed, message, type });
            }

            addLogEntry(`Processing: ${currentFile.name}`, 'step');
            addLogEntry(`File size: ${formatFileSize(currentFile.size)}`, 'info');

            const statuses = [
                { percent: 0, text: 'Uploading file...', icon: '/frontend/progresstabicons/extract.png', log: 'Uploading to server...' },
                { percent: 20, text: 'Extracting firmware...', icon: '/frontend/progresstabicons/data-transformation.png', log: 'Running binwalk extraction...' },
                { percent: 40, text: 'Analyzing binary...', icon: '/frontend/progresstabicons/filter.png', log: 'XGBoost pre-filter analysis...' },
                { percent: 60, text: 'Detecting crypto...', icon: '/frontend/progresstabicons/data-classification.png', log: 'GNN crypto classification...' },
                { percent: 80, text: 'Protocol detection...', icon: '/frontend/progresstabicons/verifying.png', log: 'XGBoost protocol classifier...' },
                { percent: 95, text: 'Finalizing...', icon: '/frontend/progresstabicons/aggregate.png', log: 'Aggregating results...' }
            ];

            let lastLogIndex = -1;
            function updateProgress(percent, statusIndex) {
                gsap.to(liquidFill, { width: `${percent}%`, duration: 0.3, ease: "power1.out" });
                progressPercent.textContent = `${percent}%`;

                const status = statuses[statusIndex];
                if (status && statusIndex !== lastLogIndex) {
                    statusTextEl.textContent = status.text;
                    statusIconEl.src = status.icon;
                    progressSpeed.textContent = 'Processing...';
                    addLogEntry(status.log, 'step');
                    lastLogIndex = statusIndex;
                }
            }

            // Show initial progress
            updateProgress(5, 0);

            try {
                // Create XMLHttpRequest for upload progress tracking
                const xhr = new XMLHttpRequest();

                const uploadPromise = new Promise((resolve, reject) => {
                    xhr.upload.addEventListener('progress', (e) => {
                        if (e.lengthComputable) {
                            const uploadPercent = Math.round((e.loaded / e.total) * 20);
                            updateProgress(uploadPercent, 0);
                        }
                    });

                    xhr.addEventListener('load', () => {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            resolve(JSON.parse(xhr.responseText));
                        } else {
                            reject(new Error(`Upload failed: ${xhr.status}`));
                        }
                    });

                    xhr.addEventListener('error', () => reject(new Error('Network error')));
                    xhr.open('POST', '/api/analyze');
                    xhr.send(formData);
                });

                // Simulate analysis progress while waiting
                let analysisInterval = setInterval(() => {
                    progress = Math.min(progress + 5, 90);
                    const statusIdx = Math.floor(progress / 20);
                    updateProgress(progress, Math.min(statusIdx, statuses.length - 1));
                }, 500);

                // Wait for API response
                const result = await uploadPromise;
                clearInterval(analysisInterval);

                // Log analysis results
                const totalTime = ((performance.now() - startTime) / 1000).toFixed(2);
                addLogEntry('Architecture detection complete', 'success');
                addLogEntry(`Detected: ${result.summary?.architecture || 'Unknown'}`, 'info');
                addLogEntry(`Crypto primitives: ${result.summary?.crypto_count || 0}`, 'info');
                addLogEntry(`Protocols: ${result.protocols?.length || 0}`, 'info');
                addLogEntry(`Analysis complete in ${totalTime}s`, 'success');

                // Complete
                updateProgress(100, statuses.length - 1);
                statusTextEl.textContent = 'Analysis complete!';
                statusIconEl.style.opacity = '0';
                uploadStatus.style.color = '#4ade80';
                gsap.to('.loading-wave', { opacity: 0, duration: 0.3 });

                // Store results and log for results page
                sessionStorage.setItem('cryptoHunterJobId', result.job_id);
                sessionStorage.setItem('cryptoHunterResults', JSON.stringify(result));
                sessionStorage.setItem('cryptoHunterLog', JSON.stringify({
                    filename: currentFile.name,
                    fileSize: currentFile.size,
                    totalTime: totalTime,
                    entries: logEntries
                }));

                // Redirect to results
                setTimeout(() => {
                    window.location.href = '/cryptex/results';
                }, 1200);

            } catch (error) {
                console.error('Upload error:', error);
                const totalTime = ((performance.now() - startTime) / 1000).toFixed(2);
                addLogEntry(`Error: ${error.message}`, 'warning');
                addLogEntry(`Failed after ${totalTime}s`, 'warning');
                statusTextEl.textContent = 'Error: ' + error.message;
                uploadStatus.style.color = '#ef4444';
                gsap.to('.loading-wave', { opacity: 0, duration: 0.3 });
            }
        }


        // Reset upload state
        function resetUpload() {
            const statusIconEl = document.getElementById('statusIcon');
            gsap.set(liquidFill, { width: '0%' });
            gsap.set('.loading-wave', { opacity: 1 });
            progressPercent.textContent = '0%';
            progressSpeed.textContent = '0 KB/s';
            document.getElementById('statusText').textContent = 'Extracting data...';
            statusIconEl.src = '/frontend/progresstabicons/extract.png';
            statusIconEl.style.opacity = '1';
            uploadStatus.style.color = '#FFFFFF';
        }

        // Back arrow click - reset
        backArrow.addEventListener('click', resetFile);

        function resetFile() {
            if (!hasFile) return;

            const tl = gsap.timeline();

            tl.to(backArrow, {
                opacity: 0,
                x: -20,
                duration: 0.3,
                ease: "power2.in"
            })
                .to(filenameOverlay, {
                    opacity: 0,
                    duration: 0.3,
                    ease: "power2.in",
                    onComplete: () => {
                        fileInput.value = '';
                        filenameText.textContent = '';
                        hasFile = false;
                        currentFile = null;
                    }
                }, "-=0.2");
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (uploadModal.style.display === 'flex') {
                    hideModal();
                } else if (hasFile) {
                    resetFile();
                }
            }

            if ((e.key === ' ' || e.key === 'Enter') && !hasFile && uploadModal.style.display !== 'flex') {
                e.preventDefault();
                fileInput.click();
            }

            if ((e.key === 'Delete' || e.key === 'Backspace') && hasFile && uploadModal.style.display !== 'flex') {
                resetFile();
            }
        });

        // Hover animations
        backArrow.addEventListener('mouseenter', () => {
            gsap.to(backArrow, { x: -5, duration: 0.3, ease: "power2.out" });
        });

        backArrow.addEventListener('mouseleave', () => {
            if (hasFile) gsap.to(backArrow, { x: 0, duration: 0.3, ease: "power2.out" });
        });

        // Utility function
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }

        // Load system status on page load
        async function loadSystemStatus() {
            try {
                const r = await fetch('/api/system-status');
                const data = await r.json();
                const container = document.getElementById('systemStatus');
                if (!container) return;

                const tools = [
                    { key: 'binwalk', name: 'Binwalk' },
                    { key: 'ghidra', name: 'Ghidra' },
                    { key: 'xgboost_filter', name: 'XGBoost' },
                    { key: 'gnn_classifier', name: 'GNN' },
                    { key: 'protocol_classifier', name: 'Protocol' },
                    { key: 'angr', name: 'Angr' },
                    { key: 'redis', name: 'Redis' },
                    { key: 'rabbitmq', name: 'RabbitMQ' },
                    { key: 'postgresql', name: 'PostgreSQL' },
                    { key: 'celery', name: 'Celery' }
                ];

                let html = '<div style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;">';
                tools.forEach(t => {
                    const comp = data.components[t.key] || {};
                    const available = comp.available;
                    const icon = available ? '✓' : (comp.icon === '○' ? '○' : '✗');
                    const color = available ? '#22c55e' : (comp.icon === '○' ? '#94a3b8' : '#ef4444');
                    html += `<span style="padding:4px 8px;background:rgba(255,255,255,0.05);border-radius:4px;" title="${comp.status || 'Unknown'}"><span style="color:${color};margin-right:4px;">${icon}</span>${t.name}</span>`;
                });
                html += '</div>';
                html += `<div style="margin-top:8px;text-align:center;color:#64748b;">${data.summary?.mode || 'standalone'} mode | Core: ${data.summary?.core_tools_ready || '?'}</div>`;

                container.innerHTML = html;
                container.style.display = 'block';
            } catch (e) {
                console.log('Could not load system status:', e);
            }
        }

        // Load status on page ready
        document.addEventListener('DOMContentLoaded', loadSystemStatus);
    </script>
</body>

</html>